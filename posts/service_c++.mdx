---
title: How to use tinyxml2 library
tags:
  - language
  - c++
date: 2023-01-18
excerpt: Learning how to use `tinyxml2` library.
cover_image: "/images/img3.jpg"
profile_image: ""
star_rating: 0
weather: Hot/Warm, Cold/Cool, Sunny/Rainy, Clear/Cloudy, Dry/Humid, Foggy/Misty, Gusty/Windy, Thunder/Lightning
---

## Purpose

Learning how to use `tinyxml2` library.

## Concept

Create a C++ Class by using the name of the service which is parsed from XML file. The service name is an element of the XML file and use the # operator and the ## operator, which are macro operators.
The C++ class is created in the naming form of "C" + "service's name". It is implemented by applying strategy pattern using C++ virtual function interface.

## Guide

1. Use the tinyxml2 library to parse the XML file. This library provides a simple API for loading and traversing XML documents. You can use its XMLDocument and XMLElement classes to read the service name, IP, and PORT elements from the file.

2. Once you have extracted the service name from the XML file, you can use the `#` and `##` `macro operators` to generate the name of the C++ class you want to create. For example, if the service name is "example", you can use the macro `#define` `CLASS_NAME` `C##example` to create the class name "Cexample".

3. To implement the strategy pattern, you will need to create a base class with a virtual function that can be overridden by subclasses. For example, you can create a Service class with a virtual `run()` method. The class generated by macro operator should inherit from this base class.

4. Implement the `run()` method in the generated class, which will be the class specific implementation of the strategy pattern.

5. In the main function, you can use the class name to create an instance of the class, and call the `run()` method to execute the specific implementation of the strategy pattern.

## Implementation - 1

1. Parsing the XML file: You can use the `tinyxml2` library to parse the XML file. First, you'll need to include the library's header file:

```c++
#include <tinyxml2.h>
```

Then, you can use the XMLDocument class to load the XML file and the XMLElement class to traverse the document and extract the service name, IP, and PORT elements. Here's an example of how to load an XML file and extract the service name:

```c++
tinyxml2::XMLDocument doc;
if(doc.LoadFile("services.xml") == tinyxml2::XML_SUCCESS) {
    tinyxml2::XMLElement* root = doc.FirstChildElement("services");
    if(root) {
        tinyxml2::XMLElement* service = root->FirstChildElement("service");
        if(service) {
            const char* serviceName = service->Attribute("name");
            // do something with the service name
        }
    }
}
```

You can use similar code to extract the IP and PORT elements from the XML file.

2. Generating the class name: Once you have extracted the service name from the XML file, you can use the `#` and `##` `macro` `operators` to generate the name of the C++ class you want to create. For example, if the service name is "example", you can use the macro `#define` `CLASS_NAME` `C##example` to create the class name "Cexample".

3. Implementing the strategy pattern: To implement the strategy pattern, you will need to create a base class with a virtual function that can be overridden by subclasses. Here's an example of a base Service class that has a virtual `run()` method:

```c++
class Service {
public:
    virtual void run() = 0;
};
```

4. Inheriting the base class: The class generated by macro operator should inherit from the base class. here is an example of how the class "Cexample" would inherit from the base class:

```c++
class CLASS_NAME : public Service {
public:
    void run() override {
        // implementation of the strategy pattern
    }
};
```

5. Using the class: In the main function, you can use the class name to create an instance of the class, and call the `run()` method to execute the specific implementation of the strategy pattern.

```c++
int main() {
    CLASS_NAME service;
    service.run();
    return 0;
}
```

## Implementation - 2

Here's an example of how you can implement a plug-in function using the strategy pattern:

1. Define a base class Service that has a virtual function `run()` and a pure virtual function `getName()`

```c++
class Service {
public:
    virtual void run() = 0;
    virtual string getName() = 0;
};
```

2. Define a class for each service, for example `Cexample` that inherits from Service and overrides the `run()` and `getName()` functions.

```c++
class Cexample : public Service {
public:
    void run() override {
        // implementation of the Cexample service
    }
    string getName() override {
        return "Cexample";
    }
};
```

3. Define a `PluginManager` class that loads the services from a shared library (dll,so..) and store the instances of the services in a map.

```c++
class PluginManager {
private:
    unordered_map<string, Service*> services;
public:
    bool load(string filename) {
        // code to load the shared library and extract the Service instances
        // store the instances in the map using the getName() function as the key
    }
    Service* getService(string name) {
        return services[name];
    }
};
```

4. In the main function, you can create an instance of the PluginManager class, load the shared library and use the `getService()` function to get the instance of a specific service and call its `run()` function.

```c++
int main() {
    PluginManager pm;
    pm.load("services.dll");
    Service* service = pm.getService("Cexample");
    service->run();
    return 0;
}
```

5. here's an example of how the `bool` `load(string filename)` function in the `PluginManager` class might be implemented on `Windows` using the LoadLibrary function from the `Windows API`:

```c++
bool PluginManager::load(string filename) {
    // Load the shared library
    HMODULE hdll = LoadLibrary(filename.c_str());
    if(hdll == NULL) {
        // Handle error
        return false;
    }

    // Get the address of the function that creates the service instance
    typedef Service* (*CreateServiceFunc)();
    CreateServiceFunc createService = (CreateServiceFunc)GetProcAddress(hdll, "createService");
    if(createService == NULL) {
        // Handle error
        return false;
    }

    // Call the function and get the service instance
    Service* service = createService();
    if(service == NULL) {
        // Handle error
        return false;
    }

    // Store the service instance in the map
    services[service->getName()] = service;
    return true;
}
```

This code uses the `LoadLibrary` function to load the shared library specified by the filename parameter. If the library can't be loaded, the function returns false. If the library is loaded successfully, the function uses the `GetProcAddress` function to get the address of the createService function. This function is implemented in the shared library and it should return an instance of the service class. The function calls this function and gets the instance of the service class.
Then it stores the service instance in the map using the `getName()` function as the key.

This is an example of how the `load()` function might be implemented on Windows. On other platforms, such as `Linux` or `macOS`, you'll need to use different functions and libraries to load shared libraries. For example, on `Linux` you can use the `dlopen`, `dlsym` and `dlclose` functions from the C library to load, retrieve symbols, and close the shared library.
